{
    "texts": {
        "definition": "Recursion is a process where a task solves itself by breaking it down into smaller, identical tasks, until reaching a simple case it can directly solve.",
        "detailDefinition": "Picture counting a stack of books not all at once, but by counting one book and asking a friend to count the remainder with the same strategy. \nThis process repeats, with each friend taking one book and passing the rest on, until only one book is leftâ€”an easy count.\nThe last friend starts by reporting their count to the friend before them, and this continues back to you, combining each count along the way to get the total. \nThis method effectively breaks down and solves a problem through repetition and aggregation.",
        "options": [
            { "id": "1", "name": "Matryoshka dolls (Russian nesting dolls) opening one after another." },
            { "id": "2", "name": "Cleaning a house room by room." },
            { "id": "3", "name": "A mirror reflecting another mirror." },
            { "id": "4", "name": "The process of making a sandwich." },
            { "id": "5", "name": "A family tree tracing back generations." },
            { "id": "6", "name": "Water flowing down a river." },
            { "id": "7", "name": "The structure of a fractal, where each part is a smaller copy of the whole." },
            { "id": "8", "name": "A countdown timer that subtracts one second until reaching zero." }
        ],
        "codeExample": " Using the book counting analogy for the factorial function:\n- Big Task: Find the factorial of a number, say 5 (which means 5 * 4 * 3 * 2 * 1).\n- Break It Down: To find 5!, find 4! first (which is 4 * 3 * 2 * 1), then multiply that by 5.\n- Stopping Point: If we reach 1, we know the factorial of 1 is just 1, so we don't need to break it down further.\n- Combine Solutions: Multiply each step's result by the next number up until we reach our original number.",
        "pythonCodeExample": "def factorial(n):\n#Base case: if n is 0, the factorial is 1\nif n == 0:\n    return 1\n# Recursive case: n! = n * (n-1)!\n else:\n    return n * factorial(n-1)\n\n# Example usage\nprint(factorial(5))  # Output: 120",
        "wrongCodeDescription": "In the provided Python function factorial, there's a small but crucial mistake that affects its functionality. Your task is to review the code carefully, identify the mistake, and correct it.",
        "wrondCode": "def factorial(n):\n# Base case: if n is 0, the factorial is 1\nif n == 1:  # Mistake here\n    return 1\n# Recursive case: n! = n * (n-1)!\nelse:\n    return n * factorial(n-1)\n\n# Example usage\nprint(factorial(5))  # What will this output be?",
        "basicTaskDescription": "Implement a Python function named fibonacci that calculates the nth number in the Fibonacci sequence using recursion. \nThe Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1:\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...",
        "basicTaskInstructions": "Base Cases:\n    If n == 0, return 0 because the first number of the Fibonacci sequence is 0.\n  If n == 1, return 1 as the second number in the sequence is 1.\n\nRecursive Step: For n > 1, the function should return the sum of the nth number's two predecessors in the sequence. This involves calling the fibonacci function recursively with n-1 and n-2.\n\nFunction Signature: Use the function signature def fibonacci(n):, where n is the position in the Fibonacci sequence of the number you want to find.\n\nExamples for Testing Your Function:\n    fibonacci(0) should return 0.\n    fibonacci(1) should return 1.\n  fibonacci(5) should return 5, since the sequence up to this point is 0, 1, 1, 2, 3, 5.",
        "basicTaskHints": "Remember that the Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the previous two.\nYour function will have two base cases and one recursive step that calls itself twice to compute the sum for n-1 and n-2.",
        "basicTaskCode": "def fibonacci(n):\n#Write your code here",
        "implementationDescription": " Implement a Python function named reverse_string that uses recursion to reverse a given string.\nTest the function with various strings, including edge cases like an empty string or a string with only one character.",
        "implementationInstructions": "    Function Signature: Define the function as def reverse_string(s):, where s is the string to be reversed.\n Base Case: If the string is empty or consists of a single character, it is its own reverse.\n    Recursive Step: For a string of length n, the reversed string can be constructed by appending the first character to the reverse of the substring that excludes this character.",
        "implementationHints": "",
        "implementationCode": "def reverse_string(s):\n#Write your code here"
    },
    "tasks": {
        "quiz": {
            "name": "Recursion Quiz",
            "question": "Which of the following best represents the concept of recursion?",
            "options": [
                { "id": "1", "name": "Matryoshka dolls (Russian nesting dolls) opening one after another." },
                { "id": "2", "name": "Cleaning a house room by room." },
                { "id": "3", "name": "A mirror reflecting another mirror." },
                { "id": "4", "name": "The process of making a sandwich." },
                { "id": "5", "name": "A family tree tracing back generations." },
                { "id": "6", "name": "Water flowing down a river." },
                { "id": "7", "name": "The structure of a fractal, where each part is a smaller copy of the whole." },
                { "id": "8", "name": "A countdown timer that subtracts one second until reaching zero." }
            ],
            "correctAnswers": "1, 5, 7, 8",
            "successMessage": "Great job! You've correctly identified the examples that best represent the concept of recursion."
        }
    }
}